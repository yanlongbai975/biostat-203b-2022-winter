---
title: "Biostat 203B Homework 2"
subtitle: Due Feb 6 @ 11:59PM
author: YANLONG BAI
output: 
  html_document:
    toc: true
    toc_depth: 4 
---

Display machine information for reproducibility:
```{r}
sessionInfo()
```


```{r setup, message=F}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, cache.lazy = FALSE)
library(R.utils)
library(tidyverse)
library(data.table)
library(lubridate)
```

```{r}
os <- sessionInfo()$running
if (str_detect(os, "Linux")) {
  mimic_path <- "/mnt/mimiciv/1.0"
} else if (str_detect(os, "macOS")) {
  mimic_path <- "/Users/huazhou/Documents/Box Sync/MIMIC/mimic-iv-1.0"
}
```

In this exercise, we use tidyverse (ggpot2, dplyr, etc) to explore the [MIMIC-IV](https://mimic.mit.edu/docs/iv/) data introduced in [homework 1](https://ucla-biostat-203b.github.io/2022winter/hw/hw1/hw1.html) and to build a cohort of ICU stays.

```{r}
# tree -s -L 2 /Users/huazhou/Documents/Box\ Sync/MIMIC/mimic-iv-1.0
system(str_c("tree -s -L 2 ", shQuote(mimic_path)), intern = TRUE)
```

## Q1. `read.csv` (base R) vs `read_csv` (tidyverse) vs `fread` (data.table)

There are quite a few utilities in R for reading plain text data files. Let us test the speed of reading a moderate sized compressed csv file, `admissions.csv.gz`, by three programs: `read.csv` in base R, `read_csv` in tidyverse, and `fread` in the popular data.table package. 

Which function is fastest? Is there difference in the (default) parsed data types? (Hint: R function `system.time` measures run times.)

**Solution**

```{r}
system.time(read.csv("/core/admissions.csv.gz"))
system.time(read_csv("/core/admissions.csv.gz"))
system.time(fread("/core/admissions.csv.gz"))
```

We can see that the function `read_csv` costs the least time, so it is the fastest one.


For later questions, we stick to the tidyverse.

## Q2. ICU stays

`icustays.csv.gz` (<https://mimic.mit.edu/docs/iv/modules/icu/icustays/>) contains data about Intensive Care Units (ICU) stays. The first 10 lines are
```{r}
system(
  str_c(
    "zcat < ", 
    shQuote(str_c(mimic_path, "/icu/icustays.csv.gz")), 
    " | head"
    ), 
  intern = TRUE
)
```

1. Import `icustatys.csv.gz` as a tibble `icustays_tble`. 

**Solution**

```{r}
icustays_tble = read_csv("/icu/icustays.csv.gz")
icustays_tble
```

2. How many unique `subject_id`? Can a `subject_id` have multiple ICU stays? 

**Solution**

```{r}
distinct(icustays_tble, subject_id, .keep_all = TRUE) %>%
  summarise(n = n())
```

The result indicates that there are only 53150 unique `subject_id`s, which is much less than the total number (76540).
So there must be some `subject_id`s having multiple ICU stays.

3. For each `subject_id`, let's only keep the first ICU stay in the tibble `icustays_tble`.

**Solution**

```{r}
icustays_tble = arrange(icustays_tble, subject_id, intime) %>%
  distinct(subject_id, .keep_all = TRUE)
icustays_tble
```

## Q3. `admission` data

Information of the patients admitted into hospital is available in `admissions.csv.gz`. See <https://mimic.mit.edu/docs/iv/modules/core/admissions/> for details of each field in this file. The first 10 lines are
```{r}
system(
  str_c(
    "zcat < ", 
    shQuote(str_c(mimic_path, "/core/admissions.csv.gz")), 
    " | head"
    ), 
  intern = TRUE
)
```

1. Import `admissions.csv.gz` as a tibble `admissions_tble`.

**Solution**

```{r}
admissions_tble = read_csv("/core/admissions.csv.gz")
admissions_tble
```

2. Let's only keep the admissions that have a match in `icustays_tble` according to `subject_id` and `hadmi_id`.

**Solution**

RMK: since in Q2.3, we only kept the first ICU stay in the tibble `icustays_tble`, so for this question, I reload this tibble again in order to contain all cases.

```{r}
icustays_tble = read_csv("/icu/icustays.csv.gz")
#testtib = tibble(subject_id, hadm_id, admittime, dischtime, deathtime, admission_type, admission_location, discharge_location, insurance, language, marital_status, ethnicity, edregtime, edregtime, edouttime, hospital_expire_flag)
testtib = admissions_tble[0,]
i = 1
j = 1
admissions_tble = arrange(admissions_tble, subject_id, hadm_id)
icustays_tble = arrange(icustays_tble, subject_id, hadm_id)
while (i < 523741) {
  while (j < 76541) {
    if(icustays_tble[j,1] == admissions_tble[i,1]){
      if(icustays_tble[j,2] == admissions_tble[i,2]){
        testtib = add_row(testtib, admissions_tble[i,])
        j = j + 1
        break
      }else if(icustays_tble[j,2] < admissions_tble[i,2]){
        j = j + 1
      }else {
        break
      }
    }else if(icustays_tble[j,1] < admissions_tble[i,1]){
      j = j + 1
    }else{
      break
    }
  }
  i = i + 1
}
admissions_tble = testtib
admissions_tble
```

If you want to use the filtered tibble "icustays_tble" to select "admissions_tble", the result is the following.

```{r}
admissions_tble = arrange(admissions_tble, subject_id, admittime)
admissions_tble_filtered = distinct(admissions_tble, subject_id, .keep_all = TRUE)
admissions_tble_filtered
```


3. Summarize the following variables by graphics. 

- admission year  
- admission month  
- admission month day  
- admission week day  
- admission hour (anything unusual?)  

**Solution**

RMK: for the following images, I use the `admissions_tble` instead of the `admissions_tble_filtered`, so if the
images have little difference with your answer, this is the reason!!!

For "admission year":

```{r}
ad_year = as.character(admissions_tble[[3]]) %>%
  substring(1, 4) %>%
  as.numeric()
y = as.data.frame(ad_year)
ggplot(data = y) + 
  geom_bar(mapping = aes(x = ad_year))
remove(y)
```

For "admission month":

```{r}
ad_month = as.character(admissions_tble[[3]]) %>%
  substring(6, 7) %>%
  as.numeric()
m = as.data.frame(ad_month)
ggplot(data = m) + 
  geom_bar(mapping = aes(x = ad_month))
remove(m)
```

For "admission month day":

```{r}
ad_monthday = as.character(admissions_tble[[3]]) %>%
  substring(9, 10) %>%
  as.numeric()
md = as.data.frame(ad_monthday)
ggplot(data = md) + 
  geom_bar(mapping = aes(x = ad_monthday))
remove(md)
```

For "admission week day" (RMK: "0" represents Sunday):

```{r}
weekday = NULL
c = 0
y = 0
week = 0
i = 1
year = 0
month = 0
ad_weekday = as.data.frame(weekday, matrix(nrow = 0, ncol = 1, dimnames = list(NULL, "weekday")))
#Zeller's congruence (the following code is written by myself)
while (i < 69212) {
  year = ad_year[i]
  month = ad_month[i]
  if(ad_month[i] == 1 || ad_month[i] == 2){
  year = ad_year[i] - 1
  month = ad_month[i] + 12
  }
  c = year %/% 100
  y = year - c * 100
  week = y + y %/% 4 + c %/% 4 - 2 * c + (26 * (month + 1)) %/% 10 + ad_monthday[i] - 1
  while (week < 0) {
    week = week + 7
  }
  week = week %% 7
  ad_weekday = rbind(ad_weekday, as.data.frame(week))
  i = i + 1
}
ggplot(data = ad_weekday) + 
  geom_bar(mapping = aes(x = week))
remove(c, i, month, week, weekday, y, year, ad_weekday, ad_month, ad_monthday, ad_year)
```

For "admission hour":

```{r}
ad_hour = as.character(admissions_tble[[3]]) %>%
  substring(12, 13) %>%
  as.numeric()
hr = as.data.frame(ad_hour)
ggplot(data = hr) + 
  geom_bar(mapping = aes(x = ad_hour))
remove(ad_hour, hr)
```

## Q4. `patients` data

Patient information is available in `patients.csv.gz`. See <https://mimic.mit.edu/docs/iv/modules/core/patients/> for details of each field in this file. The first 10 lines are
```{r}
system(
  str_c(
    "zcat < ", 
    shQuote(str_c(mimic_path, "/core/patients.csv.gz")), 
    " | head"
    ), 
  intern = TRUE
)
```

1. Import `patients.csv.gz` (<https://mimic.mit.edu/docs/iv/modules/core/patients/>) as a tibble `patients_tble` and only keep the patients who have a match in `icustays_tble` (according to `subject_id`).

**Solution**

```{r}
icustays_tble = arrange(icustays_tble, subject_id, intime) %>%
  distinct(subject_id, .keep_all = TRUE)
patients_tble = read_csv("/core/patients.csv.gz")
testtib = patients_tble[0,]
i = 1
j = 1
patients_tble = arrange(patients_tble, subject_id)
icustays_tble = arrange(icustays_tble, subject_id)
while (i < 382279) {
  while (j < 53151) {
    if(icustays_tble[j,1] == patients_tble[i,1]){
        testtib = add_row(testtib, patients_tble[i,])
        break
    }else if(icustays_tble[j,1] < patients_tble[i,1]){
      j = j + 1
    }else{
      break
    }
  }
  i = i + 1
}
patients_tble = testtib
patients_tble
```

2. Summarize variables `gender` and `anchor_age`, and explain any patterns you see.

**Solution**

```{r}
summary(as.factor(patients_tble[[2]]))# the total number of observations of two sexes.
summary(patients_tble[[3]])# the overall summary statistics of "anchor_age".
patients_tble %>%
group_by(gender) %>%
  summarise(mean(anchor_age, na.rm = TRUE))# the mean value of "anchor_age" of each gender.
```

From the result, we can see that the mean values of `anchor_age` for different gender are similar.
There is no obvious evidence to indicate a significant difference of the mean value for different genders.


## Q5. Lab results

`labevents.csv.gz` (<https://mimic.mit.edu/docs/iv/modules/hosp/labevents/>) contains all laboratory measurements for patients. The first 10 lines are
```{r}
system(
  str_c(
    "zcat < ", 
    shQuote(str_c(mimic_path, "/hosp/labevents.csv.gz")), 
    " | head"
    ), 
  intern = TRUE
)
```
`d_labitems.csv.gz` is the dictionary of lab measurements. 
```{r}
system(
  str_c(
    "zcat < ", 
    shQuote(str_c(mimic_path, "/hosp/d_labitems.csv.gz")), 
    " | head"
    ), 
  intern = TRUE
)
```

1. Find how many rows are in `labevents.csv.gz`.

**Solution**

```{bash}
gzip -cd "/hosp/labevents.csv.gz" | wc -l
```

2. We are interested in the lab measurements of creatinine (50912), potassium (50971), sodium (50983), chloride (50902), bicarbonate (50882), hematocrit (51221), white blood cell count (51301), glucose (50931), magnesium (50960), and calcium (50893). Retrieve a subset of `labevents.csv.gz` only containing these items for the patients in `icustays_tble` as a tibble `labevents_tble`. 

    Hint: `labevents.csv.gz` is a data file too big to be read in by the `read_csv` function in its default setting. Utilize the `col_select` and `lazy` options in the `read_csv` function to reduce the memory burden.

**Solution**

Since the size of `labevents_tble` is too large to run in the cycle, so here I set the `eval = FALSE`.
But for the Q5.3, we can see this cycle indeed works.

```{r, eval=FALSE}
labevents_tble = read_csv("/hosp/labevents_filtered_itemid.csv.gz")
labevents_tble = arrange(labevents_tble, subject_id)
icustays_tble = arrange(icustays_tble, subject_id) %>%
  distinct(subject_id, .keep_all = TRUE)
testtib = labevents_tble[0,]
i = 1
j = 1
while (i <30198827) {
  while (j < 53151) {
    if(icustays_tble[j,1] == labevents_tble[i,1]){
        testtib = add_row(testtib, labevents_tble[i,])
        break
    }else if(icustays_tble[j,1] < labevents_tble[i,1]){
      j = j + 1
    }else{
      break
    }
  }
  i = i + 1
}
labevents_tble = testtib

```

3. Further restrict `labevents_tble` to the first lab measurement during the ICU stay. 

**Solution**

```{r}
labevents_tble = read_csv("/hosp/labevents_filtered_itemid.csv.gz")
labevents_tble = arrange(labevents_tble, subject_id, charttime) %>%
  distinct(subject_id, .keep_all = TRUE) 
icustays_tble = arrange(icustays_tble, subject_id) %>%
  distinct(subject_id, .keep_all = TRUE)
testtib = labevents_tble[0,]
i = 1
j = 1
while (i <273582) {
  while (j < 53151) {
    if(icustays_tble[j,1] == labevents_tble[i,1]){
        testtib = add_row(testtib, labevents_tble[i,])
        break
    }else if(icustays_tble[j,1] < labevents_tble[i,1]){
      j = j + 1
    }else{
      break
    }
  }
  i = i + 1
}
labevents_tble = testtib
labevents_tble
```

4. Summarize the lab measurements by appropriate numerics and graphics. 

**Solution**

```{r}
summary(labevents_tble[[4]])# the overall summary statistics of "valuenum".
labevents_tble %>%
  group_by(itemid) %>%
      summarise(mean(valuenum, na.rm = TRUE))# the mean values of "valuenum" of different "itemid".
labevents_tble %>%
  ggplot() + 
  geom_boxplot(mapping = aes(x = as.character(itemid), y = valuenum)) # the boxplot of "valuenum" of different "itemid".
```

## Q6. Vitals from charted events

`chartevents.csv.gz` (<https://mimic.mit.edu/docs/iv/modules/icu/chartevents/>) contains all the charted data available for a patient. During their ICU stay, the primary repository of a patientâ€™s information is their electronic chart. The `itemid` variable indicates a single measurement type in the database. The `value` variable is the value measured for `itemid`. The first 10 lines of `chartevents.csv.gz` are
```{r}
system(
  str_c(
    "zcat < ", 
    shQuote(str_c(mimic_path, "/icu/chartevents.csv.gz")), 
    " | head"), 
  intern = TRUE
)
```
`d_items.csv.gz` (<https://mimic.mit.edu/docs/iv/modules/icu/d_items/>) is the dictionary for the `itemid` in `chartevents.csv.gz`. 
```{r}
system(
  str_c(
    "zcat < ", 
    shQuote(str_c(mimic_path, "/icu/d_items.csv.gz")), 
    " | head"), 
  intern = TRUE
)
```

1. We are interested in the vitals for ICU patients: heart rate (220045), mean non-invasive blood pressure (220181), systolic non-invasive blood pressure (220179), body temperature in Fahrenheit (223761), and respiratory rate (220210). Retrieve a subset of `chartevents.csv.gz` only containing these items for the patients in `icustays_tble` as a tibble `chartevents_tble`.

**Solution**

Same as Q5.2, here I set `eval = FALSE`.

```{r, eval=FALSE}
icustays_tble = read_csv("/icu/icustays.csv.gz")
chartevents_tble = read_csv("/icu/chartevents_filtered_itemid.csv.gz")
chartevents_tble = arrange(chartevents_tble, subject_id, hadm_id)
icustays_tble = arrange(icustays_tble, subject_id, hadm_id, intime)
testtib = chartevents_tble[0,]
i = 1
j = 1
while (i < 23679058) {
  while (j < 76541) {
    if(icustays_tble[j,1] == chartevents_tble[i,1]){
      if(icustays_tble[j,2] == chartevents_tble[i,2]){
        testtib = add_row(testtib, chartevents_tble[i,])
        break
      }else if(icustays_tble[j,2] < chartevents_tble[i,2]){
        j = j + 1
      }else {
        break
      }
    }else if(icustays_tble[j,1] < chartevents_tble[i,1]){
      j = j + 1
    }else{
      break
    }
  }
  i = i + 1
}
chartevents_tble = testtib

```


2. Further restrict `chartevents_tble` to the first vital measurement during the ICU stay. 

**Solution**

```{r}
icustays_tble = read_csv("/icu/icustays.csv.gz")
chartevents_tble = read_csv("/icu/chartevents_filtered_itemid.csv.gz")
chartevents_tble = arrange(chartevents_tble, subject_id, charttime) %>%
  distinct(subject_id, .keep_all = TRUE) #RMK, here I add "charttime" into the function "arrange()" in order to select the first vital measurement during the ICU stay for each patient

icustays_tble = arrange(icustays_tble, subject_id, hadm_id, intime)

testtib = chartevents_tble[0,]
i = 1
j = 1
while (i < 53151) {
  while (j < 76541) {
    if(icustays_tble[j,1] == chartevents_tble[i,1]){
      if(icustays_tble[j,2] == chartevents_tble[i,2]){
        testtib = rbind(testtib, chartevents_tble[i,])
        break
      }else if(icustays_tble[j,2] < chartevents_tble[i,2]){
        j = j + 1
      }else {
        break
      }
    }else if(icustays_tble[j,1] < chartevents_tble[i,1]){
      j = j + 1
    }else{
      break
    }
  }
  i = i + 1
}
chartevents_tble = testtib
chartevents_tble
```

3. Summarize these vital measurements by appropriate numerics and graphics. 

**Solution**

```{r}
summary(chartevents_tble[[6]])# the overall "valuenum"
chartevents_tble %>%
  group_by(itemid) %>%
      summarise(mean(valuenum, na.rm = TRUE))# the mean values of "valuenum" of different "itemid".
chartevents_tble %>%
  ggplot() + 
  geom_boxplot(mapping = aes(x = as.character(itemid), y = valuenum)) # the boxplot of "valuenum" of different "itemid".

```

I noticed that whose subject_id is "14948967" and hadm_id is "28516090" has a really large valuenum which may be a mistake, so I tried to make a new plot without this observation.

```{r}
chartevents_tblenew = chartevents_tble[chartevents_tble$valuenum < 10000,]
summary(chartevents_tblenew[[6]])
chartevents_tblenew %>%
  group_by(itemid) %>%
      summarise(mean(valuenum, na.rm = TRUE))
chartevents_tblenew %>%
  ggplot() + 
  geom_boxplot(mapping = aes(x = as.character(itemid), y = valuenum)) 

```

## Q7. Putting things together

Let us create a tibble `mimic_icu_cohort` for all ICU stays, where rows are  

- first ICU stay of each unique adult (age at admission > 18)

and columns contain at least following variables  

- all variables in `icustays.csv.gz`  
- all variables in `admission.csv.gz`  
- all variables in `patients.csv.gz`  
- first lab measurements during ICU stay  
- first vital measurements during ICU stay
- an indicator variable `thirty_day_mort` whether the patient died within 30 days of hospital admission (30 day mortality)

**Solution**

RMK: here I choose to use `full_join` instead of `left_join` since some observations only contain partial data.
If Dr. Zhou asked us to give all observations containing complete data, I will commit this is my mistake.

```{r}
icustays_tble = read_csv("/icu/icustays.csv.gz")
icustays_tble = arrange(icustays_tble, subject_id, intime) %>%
  distinct(subject_id, .keep_all = TRUE)
mimic_icu_cohort = full_join(icustays_tble, admissions_tble_filtered, by = "subject_id") %>%
  full_join(patients_tble, by = "subject_id") %>%
  full_join(labevents_tble, by = "subject_id") %>%
  full_join(chartevents_tble, by = "subject_id")
mimic_icu_cohort$thirty_day_mort_time = mimic_icu_cohort[, 12] - mimic_icu_cohort[, 10]
i = 1
while (i < 53151) {
  mimic_icu_cohort[i, 37] = as.character(mimic_icu_cohort[i, 36])
  i = i + 1
}

i = 1
mimic_icu_cohort$thirty_day_mort = "0"
while (i < 53151) {
  if(str_length(mimic_icu_cohort[i,37]) != 20){
    if(str_length(mimic_icu_cohort[i,37]) < 23){
      mimic_icu_cohort[i, 38] = "1"
      i = i + 1
    }else if(str_length(mimic_icu_cohort[i,37]) > 23){
       mimic_icu_cohort[i, 38] = "0"
       i = i + 1
    }else{
      dtime = mimic_icu_cohort[i,37] %>%
      substring(18, 22) %>%
      as.numeric()
        if(dtime < 43201){
        mimic_icu_cohort[i, 38] = "1"
        i = i + 1
        }else{
        mimic_icu_cohort[i, 38] = "0"
        i = i + 1
        }
    }
  }else{
    mimic_icu_cohort[i, 38] = "0"
    i = i + 1
  }
}
#mimic_icu_cohort$thirty_day_mort = mimic_icu_cohort[38]
mimic_icu_cohort = mimic_icu_cohort[-c(36:37)] #delete all intermediate columns that used to obtain column "thirty_day_mort".
mimic_icu_cohort %>% 
  print(n = 10, width = Inf)
```


## Q8. Exploratory data analysis (EDA)

Summarize following information using appropriate numerics or graphs.

**Solution**

- `thirty_day_mort` vs demographic variables (ethnicity, language, insurance, marital_status, gender, age at hospital admission)


`thirty_day_mort` vs `ethnicity`

```{r}
ggplot(data = mimic_icu_cohort) + 
  geom_bar(mapping = aes(x = ethnicity, fill = thirty_day_mort))
```

`thirty_day_mort` vs `language`

```{r}
ggplot(data = mimic_icu_cohort) + 
  geom_bar(mapping = aes(x = language, fill = thirty_day_mort))
```

`thirty_day_mort` vs `insurance`

```{r}
ggplot(data = mimic_icu_cohort) + 
  geom_bar(mapping = aes(x = insurance, fill = thirty_day_mort))
```

`thirty_day_mort` vs `marital_status`

```{r}
ggplot(data = mimic_icu_cohort) + 
  geom_bar(mapping = aes(x = marital_status, fill = thirty_day_mort))
```

`thirty_day_mort` vs `gender`

```{r}
ggplot(data = mimic_icu_cohort) + 
  geom_bar(mapping = aes(x = gender, fill = thirty_day_mort))
```

`thirty_day_mort` vs `age at hospital admission`

```{r}
ggplot(data = mimic_icu_cohort) + 
  geom_bar(mapping = aes(x = anchor_age, fill = thirty_day_mort))
```


- `thirty_day_mort` vs first lab measurements

```{r}
mimic_icu_cohort$test = mimic_icu_cohort$itemid.x #here since the orginal column type of "itemid.x" is numeric, there will be much blank in x-axis, so I create a new variable "test" to convert the column type to factor.
mimic_icu_cohort$test = as.factor(mimic_icu_cohort$test)
ggplot(data = mimic_icu_cohort) + 
  geom_bar(mapping = aes(x = test, fill = thirty_day_mort))
mimic_icu_cohort = mimic_icu_cohort[-37]

```

- `thirty_day_mort` vs first vital measurements

```{r}
mimic_icu_cohort$test = mimic_icu_cohort$itemid.y #Similar as above.
mimic_icu_cohort$test = as.factor(mimic_icu_cohort$test)
ggplot(data = mimic_icu_cohort) + 
  geom_bar(mapping = aes(x = test, fill = thirty_day_mort))
mimic_icu_cohort = mimic_icu_cohort[-37]

```

- `thirty_day_mort` vs first ICU unit

```{r}
ggplot(data = mimic_icu_cohort) + 
  geom_bar(mapping = aes(x = first_careunit, fill = thirty_day_mort))
```

